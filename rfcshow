#!/usr/bin/perl
# rfcshow
# Copyright (C) Eskild Hustvedt 2008, 2009
# Copyright (C) Eric Gillespie 2009
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;

use LWP::UserAgent;
use Gtk2 '-init'; # TODO: Do the init elsewhere
use constant { true => 1, false => 0 };
use Getopt::Long;
use Cwd qw(getcwd realpath);
use File::Basename;
use Compress::Zlib;
use Compress::Bzip2;
use IPC::Open3;

# Our version number
my $VERSION = '0.1 Alpha';
# The root window
my $rootWindow;
# Download parts
my $RFCSource = 'ftp://ftp.rfc-editor.org/in-notes/';
my $RFCPrefix = 'rfc';
my $RFCNum = 0;
my $RFCSuffix = '.txt';
# For compression suffix
my $RFCTail;
# The path to the config file
my $confFile = $ENV{HOME}.'/.rfcshowrc';
my @Directories;
my $UserAgent = 'rfcshow '.$VERSION.' (LWP)';
my $RFCIndex = $RFCPrefix.'-index'.$RFCSuffix;
my $RFCFile;
my $RFCFilename;

my $win; # Global var to hold the window
my $textBuf;
my $textScrollable;
my $textView; # both needed to show text
# True if the text window has already been displayed (meaning we need
# 	to destroy it before showing another one)
my $TextWindowShowing;
# Handle sigchild, needed for open3
$SIG{CHLD} = sub
{   
	my $PID = wait;
	return(1);
};
my $LWP_ProgressMode = 0;

# Config with default values
my %config = (
	source_add => 'ftp://ftp.rfc-editor.org/in-notes/',
	file_prefix => 'rfc',
	file_suffix => 'txt',
);

# Purpose: Write the RFCShow rc file
# Usage: WriteRFCShowRC();
sub WriteRFCShowRC
{
	my %configInfo = (
		HEADER => 'RFCShow RC file',
		source_add => 'The RFC source address (default: ftp://ftp.rfc-editor.org/in-notes/)',
		file_prefix => 'The prefix of the files on the server (default: rfc)',
		file_suffix => 'The suffix of the files on the server (default: .txt)',
		ignore_startup_dialog => 'Set to true to skip the about dialog on startup',
	);
	WriteConfigFile($confFile, \%config, \%configInfo);
}

# Purpose: LOad the RFCShow rc file
# Usage: LoadRFCShowRC();
sub LoadRFCShowRC
{
	my $colours = '^(black|red|green|yellow|blue|magneta|cyan|white)$';
	my $bool = '^(true|false)$';

	my %OptionRegexHash = (
		source_add => '.+',
		file_prefix => '.*',
		file_suffix => '.*',
		ignore_startup_dialog => $bool,
	);
	LoadConfigFile($confFile,\%config,\%OptionRegexHash,true);
}

# Purpose: Output a internal warning
# Usage: RSIntWarn(TEXT);
sub RSIntWarn
{
	warn("RFCShow: $_[0]\n");
}

# Purpose: die wrapper that properly outputs to STDERR, if not the message gets hidden
# Usage: RSIntDie(MESSAGE);
sub RSIntDie
{
	RSIntWarn(@_);
	die("\n");
}

# Purpose: Display an 'ok' box
# Usage: RSInfo(Title,text);
sub RSInfo
{
	my $title = shift;
	my $text = shift;
	STUB();
}

# Purpose: Display an yes/no box
# Usage: RSQuestion(Title,text);
# Returns true on yes, false on no.
sub RSQuestion
{
	my $title = $_[0] ? $_[0] : 'Untitled';
	my $text = $_[1] ? $_[1] : 'Text';
	STUB();
}

# Purpose: Display a full-screen(ish) scrollable text window
# Usage: DisplayText(TEXT STRING);
sub DisplayText
{
	my $text = shift;
	# I guess I should be setting scrollbars on this, there's no way that
	# I can display a window that's 359,200 pixels high without something crashing.
	$textBuf->set_text($text);
#	STUB()
}

# Purpose: Create a utility window
# Usage: my $utilWin = getNewUtilWin('TITLE', parent?, width?, height?);
#	Parent, width and height can be undef/omitted and will then use a sane default.
#	If called in array context, will return (win, ID) instead of just win.
sub getNewUtilWin
{
	STUB();
}

# Purpose: Create a prompt dialog, return contents
# Usage: GetInput('title','prompt text', \&CallBack);
#	This sub does not block for input, so you need to include a callback
#	which will be called with the contents of the input.
#	It will not do *anything* if the user selects cancel.
sub GetInput
{
	my $title = shift;
	my $text = shift;
	$title = $title ? $title : 'Untitled';
	$text = $text ? $text : 'This is a prompt';
	my $callback = shift;
	my ($width,$height);
	# Try to be clever calculating width and height,
	# but only when text has no newlines.
	if(not $text =~ /\n/)
	{
		$width = length($text) + 4;
		$height = 7;
	}
	else
	{
		RSIntWarn("text to GetInput() contained newlines. This might spell trouble.");
	}
	STUB();
}

# Purpose: Write a configuration file
# Usage: WriteConfigFile(/FILE, \%ConfigHash, \%ExplanationHash);
sub WriteConfigFile {
	my ($File, $Config, $Explanations) = @_;

	# Open the config for writing
	open(my $CONFIG, '>', "$File") or do {
		# If we can't then we error out, no need for failsafe stuff - it's just the config file
		RSIntWarn("Unable to save the configuration file $File: $!");
		return(0);
	};
	if(defined($Explanations->{HEADER})) {
		print $CONFIG "# $Explanations->{HEADER}\n";
	}
	foreach(sort(keys(%{$Config}))) {
		next unless length($Config->{$_});	# Don't write empty options
		if(defined($Explanations->{$_})) {
			print $CONFIG "\n# $Explanations->{$_}";
		}
		print $CONFIG "\n$_=$Config->{$_}\n";
	}
	close($CONFIG);
}

# Purpose: Load a configuration file
# Usage: LoadConfigFile(/FILE, \%ConfigHash, \%OptionRegexHash, OnlyValidOptions?);
#  OptionRegeXhash can be available for only a select few of the config options
#  or skipped completely (by replacing it by undef).
#  If OnlyValidOptions is true it will cause LoadConfigFile to skip options not in
#  the OptionRegexHash.
sub LoadConfigFile {
	my ($File, $ConfigHash, $OptionRegex, $OnlyValidOptions) = @_;

	open(my $CONFIG, '<', "$File") or do {
		RSIntWarn(sprintf("Unable to read the configuration settings from %s: %s", $File, $!));
		return(0);
	};
	while(<$CONFIG>) {
		next if m/^\s*(#.*)?$/;
		next unless m/=/;
		chomp;
		my $Option = $_;
		my $Value = $_;
		$Option =~ s/^\s*(\w+)\s*=.*/$1/;
		$Value =~ s/^\s*\w+\s*=\s*(.*)\s*/$1/;
		if($OnlyValidOptions) {
			unless(defined($OptionRegex->{$Option})) {
				RSIntWarn("Unknown configuration option \"$Option\" (=$Value) in $File: Ignored.");
				next;
			}
		}
		unless(defined($Value)) {
			RSIntWarn("Empty value for option $Option in $File");
		}
		if(defined($OptionRegex) and defined($OptionRegex->{$Option})) {
			my $MustMatch = $OptionRegex->{$Option};
			unless ($Value =~ /$MustMatch/) {
				RSIntWarn("Invalid setting of $Option (=$Value) in the config file: Must match $OptionRegex->{Option}.");
				next;
			}
		}
		$ConfigHash->{$Option} = $Value;
	}
	close($CONFIG);
}

# Purpose: Mark something as a stub
# Usage: STUB();
sub STUB
{
	my ($package, $filename, $line, $subroutine, $hasargs,
		$wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(1);
	my $msg = "STUB: $subroutine";
	RSIntWarn($msg);
}

sub STUBMenu
{
	RSIntWarn('Clicked menu item is stubbed');
}

# Purpose: Prompt for an RFC to open
# Usage: AskRFC();
sub AskRFC
{
	GetInput('Open RFC','Please enter the RFC ID you want to open', \&OpenRFC);
}

# Purpose: Opens provided RFC
# Usage: OpenRFC($rfc)
# ERR: Whoops. We never GET a $rfc - should we be prompting for one?
sub OpenRFC
{
	my $id = shift;
	# this needs to be found in each dir of @ProgressDir
	if(CheckRFC($id)) # stuffs values into $RFCFilename and $RFCTail
	{
		# FIXME: Something's fundamentally wrong with doing the same tests
		# twice

		my $RFCText = GetFile($RFCFilename,$RFCTail);
		if ($RFCText)
		{
			DisplayText($RFCText);
		}
		else
		{
			RSInfo('Error',"Error: rfc$id.txt was unable to be opened");
		}
	}
	else
	{
		RSInfo('Error',"Error: rfc$id.txt was unable to be opened");
	}
}

# Purpose: Exit the program
# Usage: ExitProg();
sub ExitProg
{
	STUB();
	exit(0);
}

# Purpose: Display the about dialog
# Usage: AboutDialog();
sub AboutDialog
{
	return RSInfo('About RFCShow',"This is RFCShow $VERSION.\nBring your own kitchen sink.\n\nCopyright (C) Eskild Hustvedt, Eric Gillespie\nand other authors");
}

# Purpose: Give help
# Usage: HelpMe();
sub HelpMe
{
	return RSInfo('Help',"Some day you will get help here.\nFor now you get this helpful dialog.");
}

# Purpose: Search dialog while I (ecg) hack and cut code
# Usage: SearchDialog(TYPE);
# TODO: this really REALLY needs work.
sub SearchDialog
{
	my $searchType = $_[0] ? $_[0] : '';
	my $searchTerm;
	# Currently mostly stubbed.
	# What should happen here is: (case switch on $searchType)
	# If $1 is blank, bring up a search dialog prompting for term
	# If $1 is REPEAT, search for the next occurence of term
	# If $1 is INDEX, search in the rfc-index for the requested term.
	# If $1 is ALL, search in the total rfc store for the requested term.
	# I should stuff any result into $searchterm
	# so I can use it for the next invocation
	if(not defined $searchType or not length $searchType)
	{
	# Hm. What should this search in? Currently loaded doc?
	#  What if we have no doc loaded?
		GetInput('Search','Input term to search for',
			sub
			{
#				my $file = shift;
#				RSInfo('Entering',"No file loaded, but you entered $file");
				my @search = Search(false, @_);
				SearchDisplay(@search);
			}
		);
	}
	elsif ($searchType eq 'ALL')
	{
		GetInput('Search All','Input term to search ALL documents for',
			sub
			{
				my $file = shift;
				RSInfo('Entering',"You entered $file");
			}
		);
	}
	elsif ($searchType eq 'INDEX')
	{
		if(open($RFCFile, '<', $RFCIndex))
		{
			GetInput('Search Index','Input term to search the RFC index for', 
				sub
				{
					my @search = Search(true, @_);
					SearchDisplay(@search);
				}
			);
		}
		else
		{
			RSInfo('Error',"Cannot open $RFCIndex");
		}
	}
	elsif ( $searchType eq 'REPEAT')
	# Makes no sense for INDEX, but does for current doc or ALL
	{
		# No longer the correct code, but for a stub, who cares.
		GetInput('Repeat Search','Input term to search for',
		sub
		{
			my $file = shift;
			RSInfo('Entering',"You entered $file");
		}
	);
	}
}

# Purpose: Search function - back end of Search dialog.
# Usage:  Search(filename,lookingFor)
# Returns:  a list of RFC numbers with the search term.
# Requires: valid open filehandle $RFCFile
# Provided by: Joshua.Gatcomb@gmail.com
sub Search
{
	my $skip_header = shift;
    my $search_str = uc(join ' ', @_);
    my @match;
	if ($skip_header) {
    # skip first 68 lines, what we want isn't there. Only relevant for the 
	# rfc-index
 	   <$RFCFile> for 1 .. 68;
	}
    {
        # paragraph mode
        local $/ = "";
        while (<$RFCFile>) {
            tr/\r\n/  /;
            s/\s+/ /;
			push @match, (split /\W+/, $_)[0] if index(uc($_), $search_str) != -1;
        }        
    }
    return @match;
}

# Purpose: open a bzip/gzip/lzma/plain file and hand its uncompressed contents on
# Usage: GetFile($filename,$tail);
sub GetFile
{
	my $filename = shift;
	my $tail = shift; # gotta check if next arg even HAS anything in it.
	my $return;

	# FIXME: We need more error handling
	# FIXME: Should check for readability as well as existance

#	if ( -e $filename) 
	if ( $tail eq '')
	{
		# Plain, just hand it on.
		$return = read_file($filename);
	}
#	elsif ( -e $filename.'.bz2')
	elsif ( $tail eq '.bz2')
	{
		# Uncompress bz2
		my $file = bzopen($filename.'.bz2','r');
		my $buffer;
		while($file->bzread($buffer))
		{
			$return .= $buffer;
		}
	}
#	elsif ( -e $filename.'.gz')
	elsif ( $tail eq '.gz')
	{
		# Uncompress gz
		my $file = gzopen($filename.'.gz','rb');
		my $buffer;
		while($file->gzread($buffer))
		{
			$return .= $buffer;
		}
	}
#	elsif ( -e $filename.'.lzma')
	elsif ( $tail eq '.lzma')
	{
		# XXX: Might want to convert to a perl module once one becomes more
		# 	widespread. 
		# FIXME: Also, this fails when no lzma installed.
		my($in,$out,$err);
		open3($in, $out, $err,'unlzma','-s',$filename.'.lzma');
		while(<$out>)
		{
			$return .= $_;
		}
		close($in);
		close($out);
		close($err);
	}
	return $return;
}

# Purpose: Display output of search
# Usage: SearchDisplay
sub SearchDisplay
{
	STUB();
}

# Purpose: Download files
# Usage: DownloadFiles(TYPE);
sub DownloadFiles
{
	STUB();
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI helpers
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Prompt the user for an integer
# Usage: $int = getIntPrompt(LABEL,DEFAULT = 1,MAX = 9999);
# 	Returns undef on 'cancel'.
# 	Returns an integer otherwise.
#
# 	LABEL is used as the GUI label.
#	DEFAULT is the default number in the dialog, defaults to 1 if not supplied
# 	MAX is the maximum number in the dialog, defaults to 9999
sub getIntPrompt
{
	my $label = shift;
	my $default = @_ ? shift : 1;
	my $max = @_ ? shift : 9999;
	my $dialog = Gtk2::Dialog->new ('', $win, 'modal',
		'gtk-cancel' => 'cancel',
		'gtk-ok'      => 'ok');
	my $hbox = Gtk2::HBox->new();
	$dialog->get_content_area()->add($hbox);
	$dialog->set_default_response ('ok');

	my $gtk2label = Gtk2::Label->new($label);
	$gtk2label->show();
	$hbox->pack_start($gtk2label,0,0,0);

	my $spinner = Gtk2::SpinButton->new_with_range(0,$max,1);
	$spinner->set_value($default);
	$spinner->set_digits(0);
	$hbox->pack_end($spinner,0,0,0);

	$hbox->show();
	$spinner->show();

	my $response = $dialog->run;
	my $return;
	if ($response eq 'ok')
	{
		$return = $spinner->get_value;
	}
	$dialog->destroy;
	return $return;
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Download helpers
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: LWP progression printer
# Usage: Used in the RFCShow_LWP_Wrapper class
sub LWPProgress
{
	my ($status, $response) = @_;
	if ($LWP_ProgressMode == 0)
	{
		$rootWindow->progress(
			-max => 100,
			-message => 'Downloading...',
		);
		$LWP_ProgressMode = 1;
		$rootWindow->setprogress(0);
	}
	if ($status eq 'tick')
	{
		$rootWindow->setprogress(1,'(unknown file size)');
	}
	elsif ($status eq 'begin')
	{
		return;
	}
	elsif ($status eq 'end')
	{
		$rootWindow->noprogress();
		return;
	}
	else
	{
		$status = int($status * 100);
		$rootWindow->setprogress($status);
	}
}

# Purpose: Fetch a URL, either returning the data or writing a file
# Usage: fetchURL( SOME_URL, FileName?);
# Will download to FileName if present, if undef then it will return
# the content;
sub fetchURL
{
	my $URL = shift;
	my $targetFile = shift;

	# Reset our state
	$LWP_ProgressMode = 0;

	# RFCShow_LWP_Wrapper is a GoldenPod wrapper around LWP, it is generated in
	# Main_Loop();
	my $UA = RFCShow_LWP_Wrapper->new(
		agent => $UserAgent.' libwwwperl',
	);
	my $response;

	# if we have a target file then we just use ->mirror, that downloads
	# it to a file instead and handles all the nasties for us.
	if ($targetFile)
	{
		$response = $UA->mirror($URL,$targetFile);
	}
	# If we don't, just use standard get
	else
	{
		$response = $UA->get($URL);
	}
	if(not $response->is_success)
	{
		RSIntWarn("Download of $URL failed: ".$response->status_line."\n");
		return;
	}
	# Return the content
	return $response->content;
}

# Purpose: Download a URL
# Usage: DownloadURL(ToDir, URL);
#  Also handles creating the ToDir
sub DownloadURL
{
	my ($ToDir, $URL) = @_;
	my $CWD = getcwd();
	if(not -d $ToDir)
	{
		mkdir($ToDir) or RSIntDie("Unable to mkdir $ToDir: $!\n");
	}
	chdir($ToDir);

	my $fileName = basename($URL);
	fetchURL($URL,$fileName);
}

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp {
	printf "%-4s %-16s %s\n", $_[0], $_[1], $_[2];
}

# Purpose: Initialize
# Usage: InitMain();
sub InitMain
{
	# Var to check if rfc-index.txt is in any of @PossibleEntries
	my $Succeed = 0;
	# Possible entries
	my @PossibleEntries;
	push(@PossibleEntries,'/usr/share/doc/rfc');
	push(@PossibleEntries,'/usr/local/share/doc/rfc');
	push(@PossibleEntries,$ENV{HOME}.'/rfcshow');
	push(@PossibleEntries,$ENV{HOME}.'/rfcs');
	# Populate @Directories
	foreach(@PossibleEntries)
	{
		if (-e $_)
		{
			push(@Directories,$_);
		}
	}
	# TODO: At this stage, if none of the dirs exist, we offer to create one in $HOME
	# Load config
	if(not -e $confFile)
	{
		WriteRFCShowRC();
	}
	else
	{
		LoadRFCShowRC();
		# Re-write it so that we're sure all entries exist
		WriteRFCShowRC();
	}
	# screen workaround
	if(defined($ENV{TERM}) and $ENV{TERM} eq 'screen')
	{
		$ENV{TERM} = 'xterm';
	}
	# Side effect is that this puts value into $RFCFilename if found
	$Succeed = CheckRFC('-index');
	if ($Succeed == 0) {
		# TODO This should show a dialog box instead.
		RSIntWarn("Cannot find $RFCIndex, please grab a copy of it from $RFCSource\n");
	}
}

# Purpose: check if document exists in @Directories
# Usage: CheckRFC($RFCNum);
sub CheckRFC
{
	my $Succeed = 0;
	$RFCNum = shift;
	foreach(@Directories)
	{
		my $try = $_."/";
		foreach my $ext (qw(none bz2 gz lzma)) {
			$RFCTail = $ext eq 'none' ? '' : '.'.$ext;
			if ( -e $try.$RFCPrefix.$RFCNum.$RFCSuffix.$RFCTail)  
			{
				# Only set if we've found it
				$RFCFilename = $try.$RFCPrefix.$RFCNum.$RFCSuffix;
				$Succeed = 1;
				last; #Yep, we've got it.
			}
		}
		last if $Succeed;
		# FIXME: Yes, this is all repeated. I'll fix it when I figure out how
	}
	return $Succeed;
}

# Purpose: frontend glue to open the RFC index.
# Usage: OpenIndex
sub OpenIndex
{
	OpenRFC('-index');
}

# Purpose: frontend glue to open the RFC Ref index.
# Usage: OpenRef
sub OpenRef
{
	OpenRFC('-ref');
}

# Purpose: Create the main UI for the user
# Usage: CreateMainUI();
sub CreateMainUI
{
	my $win = Gtk2::Window->new();
	$win->set_title('RFCShow');
	$win->set_default_size(800,650);

	$win->signal_connect('destroy' => \&ExitProg);
	$win->signal_connect('delete-event' => \&ExitProg);

	my $vbox = Gtk2::VBox->new();
	$win->add($vbox);

	# These item names are straight from the spec and probably
	# needs reworking so that they are actually understandable.
	my @MenuItems = (
		[ '/File',undef,undef,0,'<Branch>' ],
		[ '/File/Open','',\&OpenRFC, 1, '<StockItem>',  'gtk-open'],
		[ '/File/Index','',\&OpenIndex, 2, '<StockItem>',  'gtk-open'],
		[ '/File/Exit','',\&ExitProg,3, '<StockItem>',  'gtk-quit' ],
		[ '/Edit',undef,undef,0,'<Branch>'],
		[ '/Edit/Search','',\&STUBMenu,1, ],
		[ '/Edit/Repeat','',\&STUBMenu,1, ],
		[ '/Edit/Search index','',\&STUBMenu,1, ],
		[ '/Edit/Search all','',\&STUBMenu,1, ],
		[ '/Grab',undef,undef,0,'<Branch>'],
		[ '/Grab/Latest','',\&STUBMenu,1, ],
		[ '/Grab/Single','',\&STUBMenu,1, ],
		[ '/Grab/Index','',\&STUBMenu,1, ],
		[ '/Grab/Bunch','',\&STUBMenu,1, ],
		[ '/Help',undef,undef,0,'<Branch>'],
		[ '/Help/Contents','',\&STUBMenu,1, ],
		[ '/Help/About','',\&STUBMenu,1, ],
	);
	my $AccelGroup = Gtk2::AccelGroup->new;
	$win->add_accel_group($AccelGroup);
	# The item factory (menubar) itself
	my $Menu_ItemFactory = Gtk2::ItemFactory->new('Gtk2::MenuBar', '<main>', $AccelGroup);
	$Menu_ItemFactory->create_items (undef, @MenuItems);

	$vbox->pack_start($Menu_ItemFactory->get_widget('<main>'), 0, 0, 0);

	$textView = Gtk2::TextView->new();
	$textBuf = Gtk2::TextBuffer->new();
	$textScrollable = Gtk2::ScrolledWindow->new();
	my $horizPolicyScroll = 'automatic';
	my $vertPolicyScroll = 'automatic';
	$textScrollable->add($textView);
	$textScrollable->set_policy($horizPolicyScroll, $vertPolicyScroll);
	$textBuf->set_text('(text)');
	$textView->set_buffer($textBuf);
	$textView->set_editable(0);
	$textView->set_wrap_mode('word');
	$textView->set_cursor_visible(0);
	$vbox->pack_start($textScrollable,1,1,0);

	my $sbar = Gtk2::Statusbar->new();
	$sbar->push(1,'Ready');
	$vbox->pack_end($sbar,0,0,0);

	$win->show_all();
}

# Purpose: The main app loop
# Usage: MainLoop();
sub Main_Loop
{
	# Generate our private LWP subclass
	eval('package RFCShow_LWP_Wrapper; our @ISA = qw(LWP::UserAgent); sub progress { shift; return main::LWPProgress(@_)};');

	Gtk2->main();
}

GetOptions (
	'help|h' => sub {
		print "RFCShow version $VERSION\n\n";
		PrintHelp('-h','--help','Display this help screen and exit');
		PrintHelp('-v','--version', 'Display version information and exit');
		exit(0);
	},
	'version|v' => sub {
		print "RFCShow version $VERSION\n";
		exit(0);
	},
) or die "Run $0 --help for more information\n";

InitMain();
CreateMainUI();
Main_Loop();
